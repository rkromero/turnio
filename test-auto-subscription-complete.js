const { PrismaClient } = require('@prisma/client');
const { MercadoPagoConfig, Payment, Subscription } = require('mercadopago');
require('dotenv').config();

const prisma = new PrismaClient();
const mpClient = new MercadoPagoConfig({ 
  accessToken: process.env.MERCADOPAGO_ACCESS_TOKEN 
});

// Configuraci√≥n de pruebas
const TEST_CONFIG = {
  // Para pruebas r√°pidas: 2 minutos en lugar de 30 d√≠as
  testingMode: true,
  quickTestMinutes: 2, // Minutos para simular vencimiento
  
  // Datos de negocio de prueba
  testBusiness: {
    name: 'Negocio Prueba Suscripci√≥n',
    email: 'test-subscription@turnio.app',
    phone: '+5491123456789',
    planType: 'BASIC'
  },
  
  // Plan de prueba
  testPlan: {
    planType: 'BASIC',
    billingCycle: 'MONTHLY',
    priceAmount: 4900 // $49 ARS
  }
};

console.log('üöÄ === SISTEMA DE PRUEBAS DE SUSCRIPCIONES AUTOM√ÅTICAS ===\n');

async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  switch (command) {
    case 'setup':
      await setupTestEnvironment();
      break;
    case 'create':
      await createTestSubscription();
      break;
    case 'expire':
      await expireTestSubscription();
      break;
    case 'check':
      await checkExpiredSubscriptions();
      break;
    case 'webhook':
      await simulateWebhook();
      break;
    case 'cleanup':
      await cleanupTestData();
      break;
    case 'full':
      await fullTestFlow();
      break;
    default:
      showUsage();
  }
}

function showUsage() {
  console.log('üìã USO DEL SCRIPT:');
  console.log('');
  console.log('node test-auto-subscription-complete.js [comando]');
  console.log('');
  console.log('COMANDOS DISPONIBLES:');
  console.log('  setup     - Configurar entorno de pruebas');
  console.log('  create    - Crear suscripci√≥n de prueba');
  console.log('  expire    - Vencer suscripci√≥n manualmente');
  console.log('  check     - Verificar suscripciones vencidas');
  console.log('  webhook   - Simular webhook de MercadoPago');
  console.log('  cleanup   - Limpiar datos de prueba');
  console.log('  full      - Ejecutar flujo completo de pruebas');
  console.log('');
  console.log('EJEMPLOS:');
  console.log('  node test-auto-subscription-complete.js full');
  console.log('  node test-auto-subscription-complete.js setup');
  console.log('  node test-auto-subscription-complete.js cleanup');
}

async function setupTestEnvironment() {
  console.log('üîß CONFIGURANDO ENTORNO DE PRUEBAS...\n');
  
  try {
    // 1. Verificar conexi√≥n a BD
    console.log('1Ô∏è‚É£ Verificando conexi√≥n a base de datos...');
    await prisma.$connect();
    console.log('‚úÖ Conectado a PostgreSQL');

    // 2. Verificar variables de entorno
    console.log('\n2Ô∏è‚É£ Verificando variables de entorno...');
    const requiredEnvs = [
      'MERCADOPAGO_ACCESS_TOKEN',
      'MERCADOPAGO_PUBLIC_KEY',
      'BACKEND_URL',
      'FRONTEND_URL'
    ];

    for (const env of requiredEnvs) {
      if (process.env[env]) {
        console.log(`‚úÖ ${env}: ${process.env[env].substring(0, 20)}...`);
      } else {
        console.log(`‚ùå ${env}: No configurada`);
      }
    }

    // 3. Verificar configuraci√≥n de MercadoPago
    console.log('\n3Ô∏è‚É£ Probando conexi√≥n con MercadoPago...');
    const paymentClient = new Payment(mpClient);
    try {
      const payments = await paymentClient.search({
        options: { limit: 1 }
      });
      console.log('‚úÖ MercadoPago conectado correctamente');
    } catch (error) {
      console.log('‚ùå Error conectando con MercadoPago:', error.message);
    }

    console.log('\n‚úÖ ENTORNO DE PRUEBAS CONFIGURADO');

  } catch (error) {
    console.error('‚ùå Error configurando entorno:', error.message);
  }
}

async function createTestSubscription() {
  console.log('üèóÔ∏è CREANDO SUSCRIPCI√ìN DE PRUEBA...\n');

  try {
    // 1. Crear o encontrar negocio de prueba
    console.log('1Ô∏è‚É£ Configurando negocio de prueba...');
    let business = await prisma.business.findFirst({
      where: { email: TEST_CONFIG.testBusiness.email }
    });

    if (!business) {
      business = await prisma.business.create({
        data: {
          ...TEST_CONFIG.testBusiness,
          maxAppointments: 100,
          isActive: true
        }
      });
      console.log('‚úÖ Negocio creado');
    } else {
      console.log('‚úÖ Negocio encontrado');
    }

    // 2. Crear usuario de prueba
    let user = await prisma.user.findFirst({
      where: { businessId: business.id }
    });

    if (!user) {
      user = await prisma.user.create({
        data: {
          name: 'Usuario Prueba',
          email: TEST_CONFIG.testBusiness.email,
          phone: TEST_CONFIG.testBusiness.phone,
          role: 'ADMIN',
          businessId: business.id,
          password: '$2b$10$test.hash' // Hash de prueba
        }
      });
      console.log('‚úÖ Usuario creado');
    } else {
      console.log('‚úÖ Usuario encontrado');
    }

    // 3. Crear suscripci√≥n
    console.log('\n2Ô∏è‚É£ Creando suscripci√≥n...');
    const nextBillingDate = new Date();
    if (TEST_CONFIG.testingMode) {
      // Para pruebas: vence en 2 minutos
      nextBillingDate.setMinutes(nextBillingDate.getMinutes() + TEST_CONFIG.quickTestMinutes);
    } else {
      // Producci√≥n: vence en 30 d√≠as
      nextBillingDate.setDate(nextBillingDate.getDate() + 30);
    }

    const subscription = await prisma.subscription.create({
      data: {
        businessId: business.id,
        planType: TEST_CONFIG.testPlan.planType,
        status: 'ACTIVE',
        billingCycle: TEST_CONFIG.testPlan.billingCycle,
        priceAmount: TEST_CONFIG.testPlan.priceAmount,
        startDate: new Date(),
        nextBillingDate,
        // Simular ID de MercadoPago para pruebas
        mercadoPagoSubscriptionId: `test_sub_${Date.now()}`
      }
    });

    console.log('‚úÖ Suscripci√≥n creada:', {
      id: subscription.id,
      planType: subscription.planType,
      status: subscription.status,
      nextBillingDate: subscription.nextBillingDate.toISOString(),
      testingMode: TEST_CONFIG.testingMode ? 'S√ç (vence en 2 min)' : 'NO (vence en 30 d√≠as)'
    });

    // 4. Crear pago inicial
    console.log('\n3Ô∏è‚É£ Creando registro de pago inicial...');
    const payment = await prisma.payment.create({
      data: {
        subscriptionId: subscription.id,
        amount: TEST_CONFIG.testPlan.priceAmount,
        status: 'APPROVED',
        billingCycle: TEST_CONFIG.testPlan.billingCycle,
        paidAt: new Date(),
        mercadoPagoPaymentId: `test_payment_${Date.now()}`
      }
    });

    console.log('‚úÖ Pago inicial registrado:', {
      id: payment.id,
      amount: payment.amount,
      status: payment.status
    });

    console.log('\nüéâ SUSCRIPCI√ìN DE PRUEBA LISTA');
    console.log(`‚è∞ La suscripci√≥n vencer√° el: ${nextBillingDate.toLocaleString()}`);
    
    if (TEST_CONFIG.testingMode) {
      console.log(`\n‚ö° MODO PRUEBAS ACTIVADO:`);
      console.log(`   Espera ${TEST_CONFIG.quickTestMinutes} minutos y ejecuta:`);
      console.log(`   node test-auto-subscription-complete.js check`);
    }

  } catch (error) {
    console.error('‚ùå Error creando suscripci√≥n:', error.message);
  }
}

async function expireTestSubscription() {
  console.log('‚è∞ VENCIENDO SUSCRIPCI√ìN MANUALMENTE...\n');

  try {
    const subscription = await prisma.subscription.findFirst({
      where: {
        business: { email: TEST_CONFIG.testBusiness.email },
        status: 'ACTIVE'
      }
    });

    if (!subscription) {
      console.log('‚ùå No se encontr√≥ suscripci√≥n activa de prueba');
      return;
    }

    // Establecer fecha de vencimiento en el pasado
    const expiredDate = new Date(Date.now() - 60000); // 1 minuto atr√°s

    await prisma.subscription.update({
      where: { id: subscription.id },
      data: { nextBillingDate: expiredDate }
    });

    console.log('‚úÖ Suscripci√≥n vencida manualmente:', {
      id: subscription.id,
      nextBillingDate: expiredDate.toISOString()
    });

    console.log('\nüí° Ahora ejecuta: node test-auto-subscription-complete.js check');

  } catch (error) {
    console.error('‚ùå Error venciendo suscripci√≥n:', error.message);
  }
}

async function checkExpiredSubscriptions() {
  console.log('üîç VERIFICANDO SUSCRIPCIONES VENCIDAS...\n');

  try {
    // Importar la funci√≥n de verificaci√≥n
    const { checkExpiredSubscriptions } = require('./backend/src/controllers/subscriptionAutoController');
    
    console.log('1Ô∏è‚É£ Ejecutando proceso de verificaci√≥n...');
    await checkExpiredSubscriptions();

    console.log('\n2Ô∏è‚É£ Verificando resultados...');
    const subscription = await prisma.subscription.findFirst({
      where: {
        business: { email: TEST_CONFIG.testBusiness.email }
      },
      include: {
        business: true,
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 3
        }
      }
    });

    if (subscription) {
      console.log('üìä Estado actual de la suscripci√≥n:');
      console.log({
        id: subscription.id,
        status: subscription.status,
        planType: subscription.planType,
        nextBillingDate: subscription.nextBillingDate?.toISOString(),
        businessName: subscription.business.name
      });

      console.log('\nüí≥ √öltimos pagos:');
      subscription.payments.forEach((payment, index) => {
        console.log(`  ${index + 1}. ${payment.status} - $${payment.amount} - ${payment.createdAt.toISOString()}`);
      });
    }

    console.log('\n‚úÖ Verificaci√≥n completada');

  } catch (error) {
    console.error('‚ùå Error verificando suscripciones:', error.message);
  }
}

async function simulateWebhook() {
  console.log('üîî SIMULANDO WEBHOOK DE MERCADOPAGO...\n');

  try {
    const subscription = await prisma.subscription.findFirst({
      where: {
        business: { email: TEST_CONFIG.testBusiness.email }
      },
      include: {
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    });

    if (!subscription || subscription.payments.length === 0) {
      console.log('‚ùå No se encontr√≥ suscripci√≥n con pagos para simular webhook');
      return;
    }

    const latestPayment = subscription.payments[0];

    // Simular datos del webhook
    const webhookData = {
      type: 'subscription_authorized_payment',
      data: {
        id: `sim_payment_${Date.now()}`
      }
    };

    console.log('1Ô∏è‚É£ Simulando datos del webhook:', webhookData);

    // Crear un pago simulado
    const simulatedPayment = await prisma.payment.create({
      data: {
        subscriptionId: subscription.id,
        amount: subscription.priceAmount,
        status: 'APPROVED',
        billingCycle: subscription.billingCycle,
        paidAt: new Date(),
        mercadoPagoPaymentId: webhookData.data.id
      }
    });

    console.log('2Ô∏è‚É£ Pago simulado creado:', {
      id: simulatedPayment.id,
      amount: simulatedPayment.amount,
      status: simulatedPayment.status
    });

    // Actualizar suscripci√≥n
    const nextBillingDate = new Date();
    nextBillingDate.setDate(nextBillingDate.getDate() + 30);

    await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: 'ACTIVE',
        nextBillingDate
      }
    });

    console.log('3Ô∏è‚É£ Suscripci√≥n renovada:', {
      id: subscription.id,
      status: 'ACTIVE',
      nextBillingDate: nextBillingDate.toISOString()
    });

    console.log('\n‚úÖ Webhook simulado exitosamente');

  } catch (error) {
    console.error('‚ùå Error simulando webhook:', error.message);
  }
}

async function cleanupTestData() {
  console.log('üóëÔ∏è LIMPIANDO DATOS DE PRUEBA...\n');

  try {
    const business = await prisma.business.findFirst({
      where: { email: TEST_CONFIG.testBusiness.email }
    });

    if (!business) {
      console.log('‚ÑπÔ∏è No hay datos de prueba para limpiar');
      return;
    }

    console.log('1Ô∏è‚É£ Eliminando datos relacionados...');
    
    // Eliminar pagos
    await prisma.payment.deleteMany({
      where: { subscription: { businessId: business.id } }
    });
    console.log('‚úÖ Pagos eliminados');

    // Eliminar suscripciones
    await prisma.subscription.deleteMany({
      where: { businessId: business.id }
    });
    console.log('‚úÖ Suscripciones eliminadas');

    // Eliminar usuarios
    await prisma.user.deleteMany({
      where: { businessId: business.id }
    });
    console.log('‚úÖ Usuarios eliminados');

    // Eliminar negocio
    await prisma.business.delete({
      where: { id: business.id }
    });
    console.log('‚úÖ Negocio eliminado');

    console.log('\nüéâ DATOS DE PRUEBA LIMPIADOS');

  } catch (error) {
    console.error('‚ùå Error limpiando datos:', error.message);
  }
}

async function fullTestFlow() {
  console.log('üéØ EJECUTANDO FLUJO COMPLETO DE PRUEBAS...\n');

  try {
    console.log('‚ïê'.repeat(50));
    await setupTestEnvironment();
    
    console.log('\n' + '‚ïê'.repeat(50));
    await createTestSubscription();
    
    console.log('\n‚è≥ Esperando vencimiento...');
    if (TEST_CONFIG.testingMode) {
      console.log(`Esperando ${TEST_CONFIG.quickTestMinutes} minutos...`);
      await new Promise(resolve => setTimeout(resolve, TEST_CONFIG.quickTestMinutes * 60 * 1000));
    } else {
      console.log('Venciendo manualmente para pruebas...');
      await expireTestSubscription();
    }
    
    console.log('\n' + '‚ïê'.repeat(50));
    await checkExpiredSubscriptions();
    
    console.log('\n' + '‚ïê'.repeat(50));
    await simulateWebhook();

    console.log('\n' + '‚ïê'.repeat(50));
    console.log('üéâ FLUJO COMPLETO FINALIZADO');
    console.log('');
    console.log('üìã RESUMEN DE PRUEBAS:');
    console.log('‚úÖ Entorno configurado');
    console.log('‚úÖ Suscripci√≥n creada');
    console.log('‚úÖ Vencimiento procesado');
    console.log('‚úÖ Cobro autom√°tico simulado');
    console.log('‚úÖ Suscripci√≥n renovada');
    console.log('');
    console.log('üí° Para limpiar datos: node test-auto-subscription-complete.js cleanup');

  } catch (error) {
    console.error('‚ùå Error en flujo completo:', error.message);
  }
}

// Ejecutar script
main().catch(console.error).finally(() => prisma.$disconnect()); 